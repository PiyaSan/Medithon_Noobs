#input
import re

# A simple in-memory "database"
user_db = {}

# Helper function to validate email format
def is_valid_email(email):
    # Basic regex pattern for validating email
    pattern = r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$'
    return re.match(pattern, email) is not None

# Helper function to validate password strength (at least 6 characters)
def is_valid_password(password):
    return len(password) >= 6

# Step 1: User Registration
def register_user():
    print("User Registration:")
    
    # Prompt for valid email
    while True:
        email = input("Enter your email: ").strip()
        if is_valid_email(email):
            break
        else:
            print("Invalid email format. Please try again.")
    
    # Prompt for a strong password
    while True:
        password = input("Enter your password (min 6 characters): ").strip()
        if is_valid_password(password):
            break
        else:
            print("Password too short. Please enter at least 6 characters.")
    
    # Simulate sending a confirmation link
    print(f"A confirmation link has been sent to {email}. Please confirm your email.")
    
    # Email confirmation step
    while True:
        email_confirmed = input(f"Have you confirmed your email? (yes/no): ").lower().strip()
        if email_confirmed == 'yes':
            # Store the user details in the "database"
            user_db[email] = {"password": password, "email_confirmed": True}
            print("Email confirmed successfully!")
            break
        else:
            print("Please confirm your email to proceed.")
    
    # Proceed to Step 2: Confirm Diabetes Status
    confirm_diabetes_status(email)

# Step 2: Confirm Diabetes Status
def confirm_diabetes_status(email):
    print("\nDiabetes Status Confirmation:")
    
    # Ask if the user has diabetes and validate input
    while True:
        has_diabetes = input("Do you have diabetes? (yes/no): ").lower().strip()
        if has_diabetes == 'yes':
            while True:
                diabetes_type = input("Is it Type 1 or Type 2 diabetes? (Type 1/Type 2): ").lower().strip()
                if diabetes_type == 'type 1' or diabetes_type == 'type 2':
                    # Store the diabetes status in the user profile
                    user_db[email]["diabetes"] = True
                    user_db[email]["diabetes_type"] = diabetes_type
                    print(f"Diabetes Type {diabetes_type} recorded successfully.")
                    break
                else:
                    print("Invalid diabetes type. Please enter 'Type 1' or 'Type 2'.")
            break
        elif has_diabetes == 'no':
            user_db[email]["diabetes"] = False
            print("No diabetes information recorded.")
            break
        else:
            print("Invalid response. Please enter 'yes' or 'no'.")
    
    # Print out the user profile for confirmation
    print("\nUser Profile Updated:")
    print(user_db[email])

# Main function to start the registration process
def main():
    register_user()

if __name__ == "__main__":
    main()

#blood glucose level input and graph generation
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import re

# In-memory "database" to store blood glucose levels
glucose_db = {}

# Function to input blood glucose levels
def input_glucose_levels(email):
    print("Enter your blood glucose levels.") 
    print("Type 'done' when finished.")
    
    while True:
        glucose_level = input("Enter blood glucose level (mg/dL): ").strip()
        print("Type 'done' when finished.")
        # Allow the user to finish input
        if glucose_level.lower() == 'done':
            break
            
        # Validate glucose level input
        if re.match(r'^\d+$', glucose_level):
            glucose_level = int(glucose_level)
            timestamp = datetime.now()
            # Store glucose level with a timestamp
            if email not in glucose_db:
                glucose_db[email] = []
            glucose_db[email].append((timestamp, glucose_level))
            print(f"Recorded {glucose_level} mg/dL at {timestamp}.")
        else:
            print("Invalid input. Please enter a numeric glucose level.")

# Function to generate graphs
def generate_graphs(email):
    if email not in glucose_db or not glucose_db[email]:
        print("No glucose data available for this user.")
        return

    # Separate timestamps and glucose levels for plotting
    timestamps, glucose_levels = zip(*glucose_db[email])

    # Generate weekly graph
    week_start = datetime.now() - timedelta(days=7)
    week_data = [(ts, gl) for ts, gl in zip(timestamps, glucose_levels) if ts >= week_start]

    if week_data:
        week_timestamps, week_glucose_levels = zip(*week_data)
        plt.figure(figsize=(10, 5))
        plt.plot(week_timestamps, week_glucose_levels, marker='o', linestyle='-')
        plt.title('Weekly Blood Glucose Levels')
        plt.xlabel('Date')
        plt.ylabel('Glucose Level (mg/dL)')
        plt.xticks(rotation=45)
        plt.grid()
        plt.tight_layout()
        plt.show()
    else:
        print("No glucose data available for the past week.")

    # Generate monthly graph
    month_start = datetime.now() - timedelta(days=30)
    month_data = [(ts, gl) for ts, gl in zip(timestamps, glucose_levels) if ts >= month_start]

    if month_data:
        month_timestamps, month_glucose_levels = zip(*month_data)
        plt.figure(figsize=(10, 5))
        plt.plot(month_timestamps, month_glucose_levels, marker='o', linestyle='-')
        plt.title('Monthly Blood Glucose Levels')
        plt.xlabel('Date')
        plt.ylabel('Glucose Level (mg/dL)')
        plt.xticks(rotation=45)
        plt.grid()
        plt.tight_layout()
        plt.show()
    else:
        print("No glucose data available for the past month.")

# Main function to start the glucose input and graph generation process
def main():
    email = input("Enter your email: ").strip()  # Assuming the user is already registered

    input_glucose_levels(email)  # Step 3: Input Blood Glucose Levels
    generate_graphs(email)        # Step 4: Generate Weekly and Monthly Graphs

if __name__ == "__main__":
    main()

#Set alarm for insulin dose
import schedule
import time
from datetime import datetime
import threading
import pygame

# Initialize the pygame mixer
pygame.mixer.init()

# Function to simulate displaying a confirmation for insulin administration
def insulin_confirmation():
    print("\n** Alarm Ringing! **")
    confirmation = input("Did you take your insulin? (yes/no): ").strip().lower()
    
    if confirmation == 'yes':
        print("Insulin administration confirmed. Dismissing alarm.")
    else:
        print("Please remember to take your insulin.")

# Function to play alarm sound
def play_alarm_sound():
    print("Playing alarm sound...")
    pygame.mixer.music.load('alarm_sound.mp3')  # Path to your alarm sound file
    pygame.mixer.music.play()
    
    # Keep the sound playing while asking for confirmation
    while pygame.mixer.music.get_busy():
        time.sleep(1)
    insulin_confirmation()  # Trigger the confirmation after the sound finishes

# Function to simulate setting an alarm for insulin doses
def set_alarm(alarm_time):
    schedule.every().day.at(alarm_time).do(play_alarm_sound)
    print(f"Alarm set for {alarm_time}.")

# Function to run the scheduler in a separate thread
def run_scheduler():
    while True:
        schedule.run_pending()
        time.sleep(1)

# Main function for setting alarms
def main():
    # Start the scheduler in a separate thread
    scheduler_thread = threading.Thread(target=run_scheduler)
    scheduler_thread.daemon = True
    scheduler_thread.start()

    while True:
        alarm_time = input("Enter the time for your insulin dose alarm (HH:MM, 24-hour format) or 'exit' to quit: ").strip()
        
        if alarm_time.lower() == 'exit':
            break

        # Validate time format
        try:
            datetime.strptime(alarm_time, '%H:%M')
            set_alarm(alarm_time)
        except ValueError:
            print("Invalid time format. Please use HH:MM (24-hour format).")

# Run the main function
if __name__ == "__main__":
    main()
